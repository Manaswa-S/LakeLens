// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: recents.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getRecents = `-- name: GetRecents :many
SELECT 
    recents.rec_id,
    recents.action_id,
    recents.time,
    recents.action
FROM recents
WHERE recents.user_id = $1
LIMIT $2
OFFSET $3
`

type GetRecentsParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

type GetRecentsRow struct {
	RecID    int64
	ActionID int64
	Time     pgtype.Timestamptz
	Action   []byte
}

func (q *Queries) GetRecents(ctx context.Context, arg GetRecentsParams) ([]GetRecentsRow, error) {
	rows, err := q.db.Query(ctx, getRecents, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentsRow
	for rows.Next() {
		var i GetRecentsRow
		if err := rows.Scan(
			&i.RecID,
			&i.ActionID,
			&i.Time,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTour = `-- name: GetTour :one
SELECT 
    tours.tour_id,
    tours.version,
    tours.shown_at
FROM tours
WHERE tours.user_id = $1
`

type GetTourRow struct {
	TourID  int64
	Version pgtype.Int4
	ShownAt pgtype.Timestamptz
}

func (q *Queries) GetTour(ctx context.Context, userID int64) (GetTourRow, error) {
	row := q.db.QueryRow(ctx, getTour, userID)
	var i GetTourRow
	err := row.Scan(&i.TourID, &i.Version, &i.ShownAt)
	return i, err
}

const insertNewTour = `-- name: InsertNewTour :exec


INSERT INTO tours (user_id)
VALUES ($1)
ON CONFLICT (user_id) DO NOTHING
`

// ////////////////////////////////////////////////////////////////////////////////////////////////
func (q *Queries) InsertNewTour(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, insertNewTour, userID)
	return err
}

const insertRecentsBulk = `-- name: InsertRecentsBulk :exec
INSERT INTO recents (user_id, action_id, time, action, title, description)
SELECT UNNEST($1::bigint[]), UNNEST($2::bigint[]), UNNEST($3::timestamptz[]), UNNEST($4::jsonb[]), UNNEST($5::text[]), UNNEST($6::text[])
`

type InsertRecentsBulkParams struct {
	Column1 []int64
	Column2 []int64
	Column3 []pgtype.Timestamptz
	Column4 [][]byte
	Column5 []string
	Column6 []string
}

func (q *Queries) InsertRecentsBulk(ctx context.Context, arg InsertRecentsBulkParams) error {
	_, err := q.db.Exec(ctx, insertRecentsBulk,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	return err
}

const resolveDescNewLake = `-- name: ResolveDescNewLake :one
SELECT
    COUNT(locations.loc_id)
FROM locations
WHERE locations.lake_id = $1
`

func (q *Queries) ResolveDescNewLake(ctx context.Context, lakeID int64) (int64, error) {
	row := q.db.QueryRow(ctx, resolveDescNewLake, lakeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const resolveLocID = `-- name: ResolveLocID :one
SELECT
    locations.bucket_name
FROM locations
WHERE locations.loc_id = $1
`

func (q *Queries) ResolveLocID(ctx context.Context, locID int64) (string, error) {
	row := q.db.QueryRow(ctx, resolveLocID, locID)
	var bucket_name string
	err := row.Scan(&bucket_name)
	return bucket_name, err
}

const unResolveLakeName = `-- name: UnResolveLakeName :one
SELECT
    lakes.lake_id
FROM lakes
WHERE lakes.user_id = $1
AND lakes.name = $2
`

type UnResolveLakeNameParams struct {
	UserID int64
	Name   string
}

func (q *Queries) UnResolveLakeName(ctx context.Context, arg UnResolveLakeNameParams) (int64, error) {
	row := q.db.QueryRow(ctx, unResolveLakeName, arg.UserID, arg.Name)
	var lake_id int64
	err := row.Scan(&lake_id)
	return lake_id, err
}

const updateTourStatus = `-- name: UpdateTourStatus :exec
UPDATE tours
SET 
    version = $2,
    shown_at = $3
WHERE user_id = $1
`

type UpdateTourStatusParams struct {
	UserID  int64
	Version pgtype.Int4
	ShownAt pgtype.Timestamptz
}

func (q *Queries) UpdateTourStatus(ctx context.Context, arg UpdateTourStatusParams) error {
	_, err := q.db.Exec(ctx, updateTourStatus, arg.UserID, arg.Version, arg.ShownAt)
	return err
}
